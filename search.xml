<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[socket函数使用方法]]></title>
    <url>%2F2018%2F09%2F02%2Fsocket%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Socket原理及创建 在Linux网络编程模型中，套接字（Socket）用来表示一个网络连接，可以是TCP连接，也可以是UDP连接，在网络通信过程中不管是写数据还是读数据都要通过Socket来完成，因此Socket是网络通信中非常重要的一个工具。下面我们来分析一下Socket的工作原理和创建的过程。 原理说明 在Linux系统中，Socket可以作为一种进程间通信的机制，可以用于不同主机的不同进程之间的通信和数据交换。Linux内核为这一机制提供了一组应用程序接口（API），称为套接字接口（socket API）。应用程序可以通过套接字接口，来使用网络套接字，以进行数据交换。Socket在程序中可以用一个封装好的结构体类型来表示，该结构体主要包含了下面的五个字段： Socket结构体字段 字段的含义 使用的协议族 可以选择TCP、UDP、本地通信等 本机IP地址 用于表示本机地址 本机端口 用于表示本机参与通信的进程 远程服务器IP地址 用于表示远程服务器 远程服务器端口 用于表示远程服务器参与通信的进程 在套接字接口中，以IP地址及通信端口组成套接字地址。远程的套接字地址，以及本地的套接字地址完成连接后，再加上使用的协议，这个五元组，作为套接字对，之后就可以彼此交换数据。 Socket的创建 在实际通信过程中，不管是客户端还是服务器都需要先初始化一个套接字，然后再进行后续操作，Linux内核提供的Socket API中有一个socket函数可以完成这件事，其函数原型如下所示： 1int socket(int domain,int type,int protocol);//用于创建Socket实例 该函数有三个参数，均为int类型，但是它们有各自的含义，下面我们针对这三个参数进行分析： domain参数 该参数表示创建Socket所使用的协议域，也称为协议族，协议族决定了socket的地址类型，在通信中必须采用对应的地址。该参数的可能取值如下所示： | domain参数可能取值 | 取值的含义 | | :—————-: | ————————– | | AF_INET | 表示使用IPV4协议 | | AF_INET6 | 表示使用IPV6协议 | | AF_UNIX | 表示只在本机内通信的套接字 | 通常我们设置该参数为AF_INET,表示使用IPV4协议进行通信，AF_INET本质上是内核源码中定义的一个宏#define AF_INET 2,正好与上面函数原型指定的int类型。 type参数 type参数指定套接字的具体类型，该参数决定了Socket的类型，可能取值如下所示： type参数可能取值 取值的具体含义 SOCK_DGRAM 创建UDP数据报套接字，使用不连续不可靠的连接 SOCK_STREAM 创建TCP流套接字，使用稳定可靠的连接 SOCK_RAW 创建原始套接字。提供原始网络协议存取 SOCK_PACKET 与网络驱动程序直接通信 SOCK_SEQPACKET 提供连续可靠的数据包连接 SOCK_RDM 提供可靠的数据包连接 在实际编程时，我们可以根据自己的需要指定其中一个参数来选择创建的Socket类型。 protocol参数 protocol参数指定了Socket所使用的协议，常用的字段有:IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。通常情况下设置为0，通过参数domain指定的协议族和参数type指定套接字类型来确定参数。当创建原始套接字，系统无法惟一的协议，这时候就要使用该参数来指定协议。 注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。函数的使用 使用该函数需要在程序中包含两个头文件，如下所示 12#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt; 该函数返回一个int类型的值，如果函数执行成功则返回一个大于0的数，表示一个套接字描述符，可以用来索引一个套接字（类似于文件描述符），在后续的操作中可以使用该描述符来查找套接字并对其进行操作。如果函数执行失败，则返回-1。 参考文章https://blog.csdn.net/bian_qing_quan11/article/details/71713647]]></content>
      <tags>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F09%2F02%2Fepoll%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[#define用来定义一个宏 后面是具体的表达式和宏的名字 epoll的定义epoll是Linux内核中 用于处理大量文件描述符I/O的一种I/O多路复用的模型，该模型是Linux下poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。 epoll的特点： Linux内核提供的一种机制，其他类Unix系统没有提供 提供与select和poll机制类似的水平触发机制（LT)，也提供了边缘触发机制（ET)。 epoll支持的最大连接数理论上没有上限，实际上受限于内存资源和CPU资源，而select能够打开的句柄数目受到限制，在Linux下的posix_types.h定义了一个宏 #define __FD_SETSIZE 1024，表示select最多同时监听1024个fd。 epoll的最大好处是不会随着FD的数目增长而降低效率，在selec中采用轮询处理，其中的数据结构类似一个数组的数据结构，而epoll 是维护一个队列，直接看队列是不是空就可以了。 使用mmap加速内核与用户空间的消息传递。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。（也就是通过共享内存来实现内核空间域用户空间的信息交互） 网络五层协议模型：应用层，传输层，网络层，数据链路层，物理层 大量用户并发登录：考虑传输协议的选择，如TCP和UDP选择哪一个，服务器端是否需要做负载均衡和反向代理，服务器端使用的I/O机制（架构的设计和选择） select与poll区别在于记录监听事件的events的数据结构不同 拥塞控制：往往是全局性的，涉及到所有的主机和路由器，降低网络相关的所有因素流量控制：往往是点对点通信量的控制，端到端，与拥塞控制不同 cwnd:表示拥塞窗口的大小慢启动算法：每经过一轮传输，cwnd就加倍增长，从而不断增加拥塞窗口的大小，在这个过程中发送方会判断网络拥塞的情况拥塞避免：当cwnd达到一个慢启动门限值的时候，会触发拥塞避免算法，此时cwnd的增长变慢，每经历过一次往返时间就使cwnd增加1，而不是加倍，这样使cwnd缓慢的增长，比慢启动要慢的多 poll机制 读取文件描述符状态 connect函数调用过程中发生了两次握手，客户端收到ACK+SYN之后connect函数就返回listen函数，在内核中建立两个队列，一个是syn队列，接收第一次握手的请求，一个是accept队列，接收第三次握手的请求]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F09%2F02%2Fbind%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[bind函数使用在Linux网络编程中，不管是TCP编程还是UDP编程，都需要确定客户端和服务器分别使用哪一个端口进行通信，这样数据包才能正确地进行传输。对于客户端来说，我们可以在程序中指定进程发送数据使用哪一个端口，然后将套接字绑定在该端口上，这样数据包就会从端口发送出去，而在服务器端，我们可以指定程序监听的端口，然后将监听套接字绑定在上面，这样服务器就可以监听该端口并等待客户端的连接。在实际编程中，我们使用Linux系统提供的库函数bind函数来完成以上的操作。bind函数，需要三个参数，第一个参数是sockfd，套接字描述符，第二个是一个指向地址结构体的指针，第三个是该结构体的大小,返回值是错误码，该函数在客户端和服务器端都可以使用。 函数原型如下： 1int bind(int csockfd,struct sockaddr* addr,int size)； 如果函数返回值小于0，表示绑定失败，此时必须进行错误处理，调用close函数关闭套接字描述符下面是具体使用实例： 1234567error = bind(sockfd, (struct sockaddr*)&amp;my_addr, sizeof(my_addr));if(err_log != 0) &#123; perror("bind 8000"); close(sockfd); exit(-1); &#125; 从上面的程序可以看出，在调用bind函数返回之后，会进行一个异常处理，如果绑定失败程序会打印失败信息，并且关闭sockfd，这样才能确保套接字不会被非法访问。 注意事项 在使用之前应该初始化my_addr结构体各个成员的值，即使用本地网络信息（IP地址+端口)进行初始化 bind函数在服务器端使用时，如果已经绑定过一个端口，那么再绑定一就会出现错误，即不允许一个套接字绑定两个端口，而在客户端，如果在发送数据之前没有使用bind函数绑定端口，那么操作系统内核会为该套接字指定一个随机端口，之后的通信过程都使用这个端口，如果企图使用bind函数进行改变，那么程序就会出现错误。 在客户端和服务器编程使用时，bind函数绑定的是本机的网络端口，端口号范围在0-65535，一般来说应该使用标准端口（0-1024)之后的端口号，避免与其他应用程序冲突 客户端不需要（但是可以）绑定网络端口，系统会为其指定随机端口号，而服务器端则一定要将套接字绑定在该应用程序要监听的那个端口上，这样才能保证]]></content>
  </entry>
  <entry>
    <title><![CDATA[malloc和new的区别]]></title>
    <url>%2F2018%2F08%2F26%2Fmalloc%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[malloc、free和new、delete的区别malloc VS new 上一篇博客我们分析了C标准库的内存分配和释放的函数malloc、free这两个函数，相信大家对动态内存分配和释放都有了一定的了解，这里我们再分析一下C++的动态内存分配。用过C++的都应该知道，new可以用来动态创建对象，在创建对象的过程中也分配了内存空间，那么，new和malloc的区别是什么呢？下面我们就来详细说一下。 malloc是标准库的一个库函数，而new是C++语言的一个运算符，也是一个关键字，两者底层实现不同 malloc使用时需要明确指出申请多少内存，由malloc的long型参数指出，而new运算符不用这么做，我们在使用new运算符时只需要指定申请的数据类型和元素的个数（数组），new运算符会自动计算需要申请多少内存。 malloc申请成功返回一个void*类型的指针，指向所分配的内存，需要用户手动转换为所需的类 型，而new返回的是对应类型的指针。 new运算符在为类对象或者结构体变量申请内存时会自动调用对应类或结构体的构造函数，对对象或结构体变量进行初始化，因此我们可以在new一个对象的时候顺便对对象或者结构体变量进行初始化，而malloc只是简单的分配内存，分配成功之后用户需自行利用memset函数进行初始化。 malloc申请内存失败返回的是NULL指针，而new申请失败则直接抛出异常。从上面我们可以看出，new和malloc存在着很大的区别，因此在实际编程时需要谨慎使用，根据实际情况选择合适的方式来动态申请内存。 free VS delete 上面分析了malloc和new的区别，这里我们也顺便分析一下free和delete的区别吧。我们知道，free和delete都能够释放内存，那么它们不同之处是什么呢？请看下面分析： free是一个标准库函数，而delete是一个运算符，实现机制不同。 free需要传入一个由malloc返回的有效指针，并且在使用时需要先判断该指针是否为NULL指针。 delete使用时是先调用对应类对象的析构函数，再对类对象所占据的内存进行释放，而free只是简单地释放内存。 delete有两种使用方式，一种是delete p(释放一个对象所占的内存)，另一种是delete []p(释放多个对象所占的内存)，而free只有一种函数调用形式。 当然，它们也有相同之处，具体如下： delete和free都不能多次对同一块内存进行释放，否则会引起错误，但是可以重复释放NULL指针。 在对内存空间进行释放之后，不管是使用delete还是使用free，都需要将指向该内存空间的指针置空，防止出现野指针。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[malloc和free的使用]]></title>
    <url>%2F2018%2F08%2F26%2Fmalloc%E5%92%8Cfreee%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[malloc和free使用基本定义和函数原型基本定义 学习C/C++的都或多或少听说过malloc和free这两个函数吧，这两个函数是C/C++语言中用于动态分配内存和释放的函数，malloc可以向操作系统申请一定量的内存，具体申请多大的内存由参数指定，而free则是用来释放由malloc申请到的内存。malloc动态申请的内存主要来自于进程地址空间的堆区，每个进程在创建并运行的过程中，操作系统会为其分配地址空间，这个地址空间是虚拟地址空间，在32位Linux系统中一般是4GB，其中3GB是用户地址空间，1GB是内核空间，malloc申请的内存空间位于用户地址空间中的堆区。由于C/C++不支持自动垃圾回收机制，所以由malloc动态申请的内存必须由用户自己释放（归还给进程或者操作系统），在程序中我们可以使用free函数来实现对内存的回收。 函数原型 malloc和free函数的原型定义在C标准库的stdlib.h头文件中，要使用这两个函数必须先包含这个头文件，否则编译会出错，在C++程序中一般是写成#include&lt;cstdlib&gt;。 malloc原型 1void* malloc(long size); free原型 1void free(void * pointer) 使用实例 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; char *p; p=(char*)malloc(10); if(p == NULL) //必须判断是否分配成功 cout &lt;&lt; "Not enougth memory" &lt;&lt; endl; else cout &lt;&lt; "allocated at" &lt;&lt; p &lt;&lt; endl //此处可以进行对已分配内存的操作 if(p!=NULL)&#123; free(p); //回收内存 p = NULL; //注意要让指针置空，防止出现野指针 &#125; return 0;&#125; 从上述代码可以看出，malloc在分配内存时如果成功返回的是一个无类型指针，在使用之前需要对其进行强制类型转换，并且在分配之后需要对指针进行判空。在程序结束时，我们需要手动使用free函数进行释放，并且需要将指针变量设置为空指针，防止出现野指针而引起程序崩溃。 使用陷阱 malloc和free函数应该配对使用，有分配就一定有释放，否则会造成内存泄漏，并且对某块内存只能释放一次，如果释放多次会使程序运行出错，从而引起程序崩溃，因此在程序中禁止对已经释放过的内存进行释放。 当申请的内存不再需要时，应该对其进行释放，释放之后应该要将指向该内存的所有指针置空，防止出现野指针。并且，已经释放的内存不能再次被访问，除非被重新分配，否则会引起段错误。 malloc 申请内存可能会失败，在使用之前必须先检查是否可用，避免访问NULL指针而引起错误。]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
