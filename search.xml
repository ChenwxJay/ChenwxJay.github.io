<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>malloc和new的区别</title>
      <link href="/2018/08/26/malloc%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/08/26/malloc%E5%92%8Cnew%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h3 id="malloc、free和new、delete的区别"><a href="#malloc、free和new、delete的区别" class="headerlink" title="malloc、free和new、delete的区别"></a>malloc、free和new、delete的区别</h3><h4 id="malloc-VS-new"><a href="#malloc-VS-new" class="headerlink" title="malloc VS   new"></a>malloc VS   new</h4><p>   上一篇博客我们分析了C标准库的内存分配和释放的函数malloc、free这两个函数，相信大家对动态内存分配和释放都有了一定的了解，这里我们再分析一下C++的动态内存分配。用过C++的都应该知道，new可以用来动态创建对象，在创建对象的过程中也分配了内存空间，那么，new和malloc的区别是什么呢？下面我们就来详细说一下。</p><ul><li>malloc是标准库的一个库函数，而new是C++语言的一个运算符，也是一个关键字，两者底层实现不同</li><li>malloc使用时需要明确指出申请多少内存，由malloc的long型参数指出，而new运算符不用这么做，我们在使用new运算符时只需要指定申请的数据类型和元素的个数（数组），new运算符会自动计算需要申请多少内存。</li><li>malloc申请成功返回一个void*类型的指针，指向所分配的内存，需要用户手动转换为所需的类  型，而new返回的是对应类型的指针。</li><li>new运算符在为类对象或者结构体变量申请内存时会自动调用对应类或结构体的构造函数，对对象或结构体变量进行初始化，因此我们可以在new一个对象的时候顺便对对象或者结构体变量进行初始化，而malloc只是简单的分配内存，分配成功之后用户需自行利用memset函数进行初始化。</li><li>malloc申请内存失败返回的是NULL指针，而new申请失败则直接抛出异常。<br>从上面我们可以看出，new和malloc存在着很大的区别，因此在实际编程时需要谨慎使用，根据实际情况选择合适的方式来动态申请内存。</li></ul><h4 id="free-VS-delete"><a href="#free-VS-delete" class="headerlink" title="free VS delete"></a>free VS delete</h4><p>  上面分析了malloc和new的区别，这里我们也顺便分析一下free和delete的区别吧。我们知道，free和delete都能够释放内存，那么它们不同之处是什么呢？请看下面分析：</p><ul><li>free是一个标准库函数，而delete是一个运算符，实现机制不同。</li><li>free需要传入一个由malloc返回的有效指针，并且在使用时需要先判断该指针是否为NULL指针。</li><li>delete使用时是先调用对应类对象的析构函数，再对类对象所占据的内存进行释放，而free只是简单地释放内存。</li><li>delete有两种使用方式，一种是delete p(释放一个对象所占的内存)，另一种是delete []p(释放多个对象所占的内存)，而free只有一种函数调用形式。</li><li>当然，它们也有相同之处，具体如下：</li><li><p>delete和free都不能多次对同一块内存进行释放，否则会引起错误，但是可以重复释放NULL指针。</p></li><li><p>在对内存空间进行释放之后，不管是使用delete还是使用free，都需要将指向该内存空间的指针置空，防止出现野指针。</p></li></ul>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>malloc和free的使用</title>
      <link href="/2018/08/26/malloc%E5%92%8Cfreee%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/08/26/malloc%E5%92%8Cfreee%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="malloc和free使用"><a href="#malloc和free使用" class="headerlink" title="malloc和free使用"></a>malloc和free使用</h2><h3 id="基本定义和函数原型"><a href="#基本定义和函数原型" class="headerlink" title="基本定义和函数原型"></a>基本定义和函数原型</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>  学习C/C++的都或多或少听说过malloc和free这两个函数吧，这两个函数是C/C++语言中用于<strong>动态分配内存和释放</strong>的函数，malloc可以向操作系统申请一定量的内存，具体申请多大的内存由参数指定，而free则是用来释放由malloc申请到的内存。malloc动态申请的内存主要来自于进程地址空间的堆区，每个进程在创建并运行的过程中，操作系统会为其分配地址空间，这个地址空间是虚拟地址空间，在32位Linux系统中一般是4GB，其中3GB是用户地址空间，1GB是内核空间，malloc申请的内存空间位于用户地址空间中的堆区。由于C/C++不支持自动垃圾回收机制，所以由malloc动态申请的内存必须由用户自己释放（归还给进程或者操作系统），在程序中我们可以使用free函数来实现对内存的回收。</p><h4 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h4><p>   malloc和free函数的原型定义在C标准库的stdlib.h头文件中，要使用这两个函数必须先包含这个头文件，否则编译会出错，在C++程序中一般是写成<code>#include&lt;cstdlib&gt;</code>。</p><p>  malloc原型 <br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">long</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>  free原型 <br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> * pointer)</span></span></span><br></pre></td></tr></table></figure><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例 "></a>使用实例 <br></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    p=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="comment">//必须判断是否分配成功</span></span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"Not enougth memory"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"allocated at"</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">    <span class="comment">//此处可以进行对已分配内存的操作</span></span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(p); <span class="comment">//回收内存</span></span><br><span class="line">        p = <span class="literal">NULL</span>; <span class="comment">//注意要让指针置空，防止出现野指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可以看出，malloc在分配内存时如果成功返回的是一个无类型指针，在使用之前需要对其进行强制类型转换，并且在分配之后需要对指针进行判空。在程序结束时，我们需要手动使用free函数进行释放，并且需要将指针变量设置为空指针，防止出现野指针而引起程序崩溃。</p><h3 id="使用陷阱"><a href="#使用陷阱" class="headerlink" title="使用陷阱"></a>使用陷阱</h3><ul><li>malloc和free函数应该配对使用，有分配就一定有释放，否则会造成内存泄漏，并且对某块内存只能释放一次，如果释放多次会使程序运行出错，从而引起程序崩溃，因此在程序中禁止对已经释放过的内存进行释放。</li><li>当申请的内存不再需要时，应该对其进行释放，释放之后应该要将指向该内存的所有指针置空，防止出现野指针。并且，已经释放的内存不能再次被访问，除非被重新分配，否则会引起段错误。</li><li>malloc 申请内存可能会失败，在使用之前必须先检查是否可用，避免访问NULL指针而引起错误。</li></ul>]]></content>
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
